# Network
## HTTP
### Popular Questions

#### **从输入网址到网页显示** 

> 一句话总结: **DNS查地址 → TCP握手建连接 → 发HTTP请求 → 收HTTP响应 → 浏览器渲染页面**

##### 1. 查地址（DNS 解析）

第一步是先找到服務器的地址：比如説输入了 `www.baidu.com`，但我們要找到對應的IP地址，（比如 `110.242.68.66`）才能訪問。

查找顺序：浏览器缓存 → 电脑本地缓存 → 路由器缓存 → 运营商DNS服务器 → 逐级向上查询，直到找到为止。

##### 2. 建立连接（TCP 三次握手）

找到地址后，你的电脑要跟目标服务器**确认双方都在线、都能通信**，通过"三次握手"：

1. **你 → 服务器**："你好，在吗？"
2. **服务器 → 你**："在的，你能听到我吗？"
3. **你 → 服务器**："能听到，我们开始吧！"

如果是 HTTPS 网站，这一步还会多一个**加密协商（TLS握手）**，相当于双方约定一个"暗号"，之后的对话都加密传输。

##### 3. 发送 HTTP 请求

连接建好后，浏览器发出一个**HTTP请求**，大意是："请把你首页的内容给我。"

> 你对服务器说：“请把你家的首页（/index.html）借给我看看。我用的是最新的 HTTP 协议，而且我支持接收图片、文字等各种格式。”（这就是 **HTTP 请求报文**）

##### 4. 服务器处理并返回 HTTP 响应

服务器收到请求后，去仓库里找到对应的网页文件（HTML、CSS、JS、图片等），打包发回给你。

> 服务器把你要的首页文件（HTML代码）打包好，贴上标签“**200 OK**”（表示“没问题，这是你要的东西”），然后顺着原路给你送回来。（如果找不到，就会贴个 **404 Not Found**）。

##### 5. 浏览器渲染页面

浏览器收到数据后，开始"组装"页面，顺序大致如下：

1. **解析 HTML** → 构建 DOM 树（网页的骨架）

2. **解析 CSS** → 构建 CSSOM 树（网页的样式）
   遇到 JS 时：
   - 无标记：阻塞解析，下载并执行完才继续
   - async：并行下载不阻塞，但下载完立刻执行（仍会短暂中断解析）
   - defer：先下载不阻塞，HTML 解析完后才按顺序执行 ✅ 最优

3. **DOM & CSSOM 合并成渲染树（Render Tree）** → 过滤不可见元素，确定样式

4. **布局（Layout）** → 计算每个元素的精确位置和大小

5. **绘制（Paint）+ 合成（Compositing）** → 调用 GPU 绘制像素，合成图层，显示到屏幕

> 整个过程都是流水线式的: HTML 一边往里送，DOM 一边在建，CSS 一边在解析，渲染树一边在合并，浏览器一边在画。每个环节不需要等前一个环节全部完成，有数据进来就开始处理。

> 唯一真正会"卡住流水线"的就是没有 async/defer 的 JS——它会强制暂停整条线，等自己执行完才让流水线继续。

(Extra)
6. 回流（Reflow）和重绘（Repaint）
    - 回流: 元素的位置或大小变了 → 浏览器要重新计算布局（重新排列）→ 开销大
    - 重绘: 元素的外观变了（颜色、背景等），但位置大小没变 → 只需要重新画一下 → 开销较小

> 关键点：回流一定会触发重绘，但重绘不一定触发回流。 因为你改了位置，画面肯定也要重画；但你只改了颜色，位置没动，就不需要重新布局。


#### **HTTP 状态码**

| 类别 | 理解 |
|------|----------|
| **1xx** | 服务器说"收到了，**还在处理中**"（中间状态，临时响应） |
| **2xx** | 服务器说"**处理完了**，成功了"（最终状态） |
| **3xx** | 服务器让跳转 **去一个不同的 URL** |
| **4xx** | 客户端的问题 |
| **5xx** | 服务器的问题 |

实际开发中 1xx 很少见，你几乎不会直接碰到它。最常见的 `100 Continue` 是用在大文件上传的场景——客户端先问服务器"我要传一个很大的文件，你准备好了吗？"，服务器回 100 表示"准备好了，传吧"。日常开发基本可以忽略 1xx。

##### 最常见的几个必须记住

**成功类：**
- **200 OK**：一切正常，这是你要的东西
- **304 Not Modified**：资源没变过，直接用你之前缓存的就行（省流量、加快速度）

**重定向：**
- **301**：永久搬家了（旧网址永远跳转到新网址）
- **302**：临时搬家（下次还可以来旧地址试试）

**客户端错误：**
- **403 Forbidden**：你没权限，服务器拒绝你
- **404 Not Found**：你要的东西不存在（最常见的错误页面）

**服务器错误：**
- **500**：服务器内部出错了
- **502 Bad Gateway**：服务器之间通信出问题了
- **503**：服务器太忙了或在维护


#### GET 和 POST 的区别
| | GET | POST |
|---|---|---|
| 语义 | 查询、获取数据 | 创建、修改数据 |
| 参数位置 | 参数直接放在 URL 里（可见） | 参数放在请求体（body）里（不可见） |
| 幂等 | ✅ 重复执行安全 | ❌ 可能有副作用 (所以浏览器刷新 POST 页面时会弹出"确认重新提交"的警告) |
| 缓存 | ✅ 可以被缓存（浏览器、CDN 等），因为结果可以复用 | ❌ 不适合，因为每次提交可能产生不同结果 |
| 敏感数据 | ❌ 别用 | ✅ 相对更安全 |


**安全性**
- 两者在 HTTP 下**都不安全**，因为 HTTP 协议本身是明文传输的，都需要 HTTPS 加密
- 但 GET 的参数暴露在 URL 里，会被浏览器历史记录、日志保存，所以**更容易泄露敏感信息**。密码、银行卡号这类数据绝对不要用 GET 传

**长度限制**
- 准确来说，**HTTP 协议本身没有限制**，是浏览器和服务器对 URL 长度有限制（通常 2048 字符左右），所以间接限制了 GET。
- POST 的 body 理论上没有上限，但服务器通常也会设置一个最大值。
