# Redis Caching
## Introduction
### Why Fast

Redis 把所有数据存在内存 (RAM) 中，而不是像传统数据库（如 MySQL）那样主要存在磁盘上。
所以 Redis 很快，读写性能非常高十万级别的请求。

### Use Case
1. 分布式锁（Distributed Lock）

- 在单机应用中，Java 可以用 synchronized 或 ReentrantLock 来保证同一时刻只有一个线程执行某段代码。
- 但当应用部署在**多台服务器**上时，Java 自带的锁就失效了——因为它们只能管自己那台机器上的线程。

> Redis: 这时候就需要一个**所有服务器都能访问的"中间人"**来充当锁

2. 公共变量（共享数据/共享缓存）

当应用部署在多台服务器上时，每台服务器的本地内存是互相隔离的。比如用户的登录状态（Session）如果只存在某一台服务器的内存里，用户下次请求被负载均衡分配到另一台服务器时，就会发现"没有登录"。

Redis 作为一个独立的、所有服务器都能访问的内存数据库，天然适合存放这些需要多台机器共享的数据：

- Session 共享：用户登录信息存到 Redis，任何一台服务器都能读取

- 缓存：热点数据（如商品信息）存一份到 Redis，所有服务器共用，避免每台服务器各查一次数据库

- 计数器：比如全局的点赞数、访问量，所有服务器往同一个 Redis key 上累加

服务器則通过远程 RPC 调用访问 Redis。

> RPC（Remote Procedure Call 远程过程调用）
简单理解：服务器 A 想往 Redis 读写数据，但 Redis 运行在另一台机器上，所以需要通过网络通信来完成操作。这个通过网络调用远程服务的过程就叫 RPC -- 它不规定你用什么方式通信。你可以用 HTTP 来实现 RPC，也可以用其他协议。


### 集群 Cluster
#### Why Cluster
如果只有一台 Redis 服务器，一旦它宕机了，因为数据存在内存（RAM）里，所有缓存数据就全丢了。这就是**单点故障**问题。

所以需要增加更多 Redis 服务器组成集群来保证可靠性（比如主从复制、哨兵模式、集群模式等）。

#### 多台 Redis 之间的通信
这些 Redis 服务器之间是互相独立的进程，可能运行在不同的机器上，所以它们之间的通信也是通过网络进行的，本质上也是 RPC（远程调用）。