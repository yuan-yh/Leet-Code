# 秒杀系统

## Workflow

> 核心思想就是层层过滤：每一层都减少请求量，到最后真正操作数据库的请求已经很少了，系统就扛得住了。

```
秒杀前  →  同步库存到Redis（准备）
秒杀中  →  Redis扣库存 + 发MQ（扛并发）
秒杀后  →  MQ消费者慢慢写MySQL（落库）

---
同步库存到Redis（准备）
    ↓
网关（过滤 + 路由）
    ↓
分布式限流（尽早挡住大部分请求）
    ↓
负载均衡（合理分配到多台服务器）
    ↓
Redis 查库存 + DECR 扣减（原子防超卖）
    ↓
拼JSON → 丢进 MQ（异步，削峰）
    ↓
消费者慢慢处理 → 写入 MySQL（最终落库）
```

### 0. 提前把商品信息同步到 Redis

MySQL 是基于磁盘的，读写速度有上限，秒杀瞬间几十万请求同时查库存，MySQL 扛不住会直接崩溃。

所以提前把商品信息（尤其是库存数量）同步到 Redis 里，所有的库存查询和扣减都在 Redis 内存中完成，根本不碰 MySQL，速度快了几个数量级。

### 1. 网关（Gateway, 过滤非法请求 & 路由分发）

秒杀场景下，瞬间会涌入大量请求，其中有很多是不合法的（比如机器人刷单、恶意攻击）。如果这些请求全部打到后端服务，系统会直接崩溃。

网关作为第一道防线，主要做两件事：

1. 过滤非法用户：

- 比如没有登录的请求直接拒绝、同一个 IP 短时间内请求过多直接限流、检测到机器人行为直接封禁、校验请求参数是否合法等等。

- 这样大量垃圾请求在网关这一层就被挡掉了，不会浪费后端资源。

2. 分发请求到对应的服务：

- 过滤之后剩下的合法请求，网关根据请求的路径或类型，把它们路由到正确的后端微服务。

- 比如下单请求发到订单服务、查库存请求发到库存服务、支付请求发到支付服务。

### 2. 分布式限流（尽早挡住大部分请求）

通常是在网关层或者紧接着网关之后就做的，而不是放在负载均衡之后。比如秒杀商品只有 100 件，却来了 100 万个请求，你要在最前面就把大部分请求拒绝掉，不然后面的服务器再多也扛不住。限流通常会用 Redis 来实现。

> 设一个阈值，超过就直接拒绝。


常见的限流策略：

- **计数器**（最简单）：用 Redis 记一个计数器，比如设定每秒只放行 1 万个请求。`Redis INCR counter → 值 ≤ 10000 放行，值 > 10000 直接拒绝`。每秒重置一次计数器，基本上先到先得，晚来的被拒绝。

- **令牌桶（Token Bucket）**：系统以固定速率往桶里放令牌（比如每秒放 1 万个）。每个请求必须拿到令牌才能通过，桶空了就拒绝。好处是可以允许短暂的突发流量（桶里可以积攒一些令牌）。

- **随机拒绝**：当流量超过阈值时，随机丢弃一部分请求。不是"晚来的被拒绝"，而是运气不好的被拒绝，相对更公平。

被拒绝的用户看到的就是"系统繁忙"或"手慢了"。

### 3. 负载均衡（合理分配到多台秒杀服务器）

每台秒杀服务器做的事情都一样：接收请求、调用 Redis 扣库存、发 MQ。只是把流量分摊到多台机器上，避免一台扛不住。

而 Redis 只有一个（或者一个集群），正因为它是单线程的，所有秒杀服务器的扣库存请求到了 Redis 这里都要排队，这才保证了不会超卖。

> 多台秒杀服务器是为了分摊处理请求的压力，Redis 单实例是为了保证库存扣减的原子性。

```
                    ┌→ 秒杀服务器A ──┐
用户请求 → 网关 → 负载均衡 ──→ 秒杀服务器B ──→ 同一个 Redis（扣库存）
                    └→ 秒杀服务器C ──┘
                                         ↓
                                        MQ
                                         ↓
                                       MySQL
```

### 4. 处理超卖（Redis 单线程排队）

Redis 是单线程的，所有命令排队执行，所以用 INCR/DECR 扣减库存天然是原子的：

```
库存初始值: stock = 100

用户A请求 → Redis DECR stock → 返回 99 → 大于0 → 允许继续
用户B请求 → Redis DECR stock → 返回 98 → 大于0 → 允许继续
...
用户X请求 → Redis DECR stock → 返回 0  → 等于0 → 允许继续
用户Y请求 → Redis DECR stock → 返回 -1 → 小于0 → 拒绝，秒杀结束
```

因为是单线程排队，不可能两个请求同时读到相同的库存值，所以不会超卖。

### 5. MQ 消费者**异步**处理 → 写入 MySQL

扣减 Redis 库存后，真正的下单（写入 MySQL、生成订单、扣款）是很重的操作。如果让用户同步等待这些操作完成，系统会很慢。所以用异步的方式：

```
用户请求
    ↓
Redis扣库存成功
    ↓
秒杀服务器自己把订单信息拼成JSON报文（包含用户ID、商品ID、数量等）
    ↓
发送到消息队列（MQ）→ 立刻返回给用户"抢购成功，正在处理"
    ↓
消费者从MQ中一条一条取出来，慢慢处理（写MySQL、创建订单、支付等）
```

> 这样做的好处是**削峰**：瞬间的高并发请求被 MQ 缓冲住了，后端可以按自己的节奏慢慢消费处理，MySQL 不会被压垮。